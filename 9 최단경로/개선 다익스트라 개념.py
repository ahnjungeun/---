# 입력 받기
import sys, heapq
input = sys.stdin.readline

# n 노드 수, m 입력 수
n,m = map(int,input().split())
# v 시작노드
v = int(input())

G = [[] for _ in range(n+1)]
for _ in range(m):
    # a b 인접노드 w 가중치
    a,b,w = map(int,input().split())
    G[a].append((b,w))

# 초기값 무한으로 설정하기
INF = int(1e9)
# 최단거리 저장 리스트
distance = [INF]*(n+1)

def dij(start):
    # 각 노드로 가는 여러 경로(소요거리)를 다 저장할 힙 정의
    q = []

    # 힙에 (start노드까지 오는 최단거리,방문노드) 튜플 삽입
    # --------
    # 아 이게 (최단거리,노드)가 아니었음 ㄷㅂ;;
    # (거리,노드 A) : 시작노드에서 A노드까지 걸리는 거리!
    # 이 거리가 최단거리일 수도 아닐 수도 있음!! 
    # 최단거리를 설정하는 게 아니라 시작노드~시작노드까지 거리니까 0인 것!
    # 니동빈씨~! 설명을 그렇게 하면 어떡해요~!~!
    heapq.heappush(q,(0,start))

    # 첫 시작노드는 최단거리 0으로 설정
    # 왜 앤 여기서 갱신하냐?
    # while에서는 pop한 노드와 인접한 노드 거리를 갱신할 거니까!
    # 첫 시작노드는 for에서 접근할 수가 없음!
    # (있는데 시작점에서 빙빙 돌아 다시 시작점으로 올 이유가 없으니까!)
    distance[start] = 0

    # 큐 빌 때까지
    # 각 노드로 가는 여러 경로를 다 탐색할 때까지
    while q:
        # 큐에 있는 노드 중 최단거리인 노드 선택
        # dist == 시작노드 → v 거리
        dist, v = heapq.heappop(q)

        # 이게 뭔 소린고 하니...
        # 방금 꺼낸 노드의 거리가 
        # 꺼낸 노드의 기존 최단거리보다 작거나 같냐? 이말이지
        # 그니까 기존 최단거리를 갱신할 가치가 있냐 확인하는 것 (1차확인)

        # 이 조건 자체가 방문여부도 판단하는 것
        # 지금 pop한 dist와 v가 이 조건을 통과하지 못하면
        # 이전에 방문하면서 최단거리가 정해진 것
        # ...? 계속 방문은 하는데 음.... 책 다시 읽고 올게용!
        # --------
        # dist가 시작노드에서 현재 pop한 노드 v까지 걸리는 거리를 저장한 변수!
        # 이 거리 dist가 최단경로를 저장해놓은 distance[v] 리스트의 값이랑 비교해서
        # 이전보다 짧은 경로였다면 
        # 시작노드에서 v를 거쳐 다른 노드 ABC...등으로 가는 경로가 최단거리로 갱신될 여지가 있으니까
        # for 돌면서 확인해보는 것!
        # 그래서 ⬇️ 이 조건의 의미가 뭐냐면~
        print()
        print('v d[v] d')
        print(v,distance[v],dist)
        if distance[v] == dist:
            print('통과')
            # 아 뭔 소린지 이제 알았네 애초에 distance[v]가 v의 dist보다 클 수 없음
            # 말이 안 되는 상황을 이해하려니까 막힌 것
            # 이 조건을 통과하는 경우는 == 인 경우
            # 밑에서 최단거리로 갱신하고➡️그 최단거리를 큐에 넣었는데 (순서중요)
            # 어떻게 큐에서 꺼낸 게 최단거리보다 크겠니!!!!
            # 무조건 같은 경우밖에 없음!!!
            # 그래서 >= 보다는 == 로 바꾸는 게 맞을 듯
            # 책에서 < 하고 continue여서 무턱대고 반대(>=)로만 바꾸니까 괜히 헷갈렸네^^;


            # 이제 G에서 v에 인접한 노드를 살펴볼 것
            # v에 인접한 노드!!!! v 아님
            for i,w in G[v]:
                # w가 노드인데...엥? (아님)
                # 아 오키 이해함 q 큐는 (거리,노드)로 넣고
                # G 그래프는 (노드,거리)로 넣었음!
                # 지금 꺼내는 건 G에서 꺼낸 것!

                # v와 인접한 노드 i까지 가는 거리 살펴보기
                # 지금까지 온 거리 dist에 i노드 거리를 더해서
                # 시작노드 → ... → v → i 까지 걸리는 총거리 계산
                # dist == 시작노드 → v 거리
                # w == v → i 거리
                cost = dist+w

                # 새로 계산한 거리(시작노드 → i)가 더 짧으면
                if cost<distance[i]:

                    # 최단거리 갱신하기
                    distance[i] = cost

                    # (갱신한 최단거리,갱신노드) 삽입
                    # 근데 이게 힙이라서 반복하다보면
                    # 맨 나중에 갔을 때! 지금 넣은 게 최단거리가 아닐 수 있음
                    # 그럼 우선순위에서 밀리고 밀려서 나중엔 그냥 pop만 되고 반복이 끝남
                    # 지금 이 순간에는 최단거리가 맞음!
                    heapq.heappush(q,(cost,i))

dij(v)
print(*distance)

# 6 11
# 1
# 1 2 2
# 1 3 5
# 1 4 1
# 2 3 3
# 2 4 2
# 3 2 3
# 3 6 5
# 4 3 3
# 4 5 1
# 5 3 1
# 5 6 2